# Phase 3: Core Development (2-3 hours)

**Objective**: Experience AI-assisted development by watching LeanVibe Agent Hive autonomously implement core features of our Medium clone through intelligent agent coordination.

## ğŸ¯ Learning Goals

In this phase, you'll witness and participate in:
- **Autonomous Feature Development**: Agents implementing complex features independently
- **Multi-Agent Coordination**: Specialized agents working together on different aspects
- **Quality-Driven Development**: Comprehensive testing and validation at every step
- **Real-time Collaboration**: Human oversight with AI-first development

## ğŸ¤– AI-First Development Approach

### Agent Specialization Strategy

LeanVibe Agent Hive will deploy specialized agents for different aspects of development:

```mermaid
graph LR
    O[Orchestrator] --> BA[Backend Agent]
    O --> FA[Frontend Agent]
    O --> QA[QA Agent]
    
    BA --> |Implements| API[FastAPI Endpoints]
    BA --> |Designs| DB[Database Models]
    FA --> |Creates| UI[Lit Components]
    FA --> |Manages| STATE[State Management]
    QA --> |Writes| TESTS[Comprehensive Tests]
    QA --> |Validates| QUALITY[Quality Gates]
```

Each agent brings specialized knowledge:
- **Backend Agent**: FastAPI, SQLAlchemy, JWT authentication, API design
- **Frontend Agent**: Lit components, Progressive Web Apps, responsive design
- **QA Agent**: pytest, test automation, performance validation, security testing

## ğŸš€ Feature Implementation Roadmap

### 3.1 User Authentication System (45 minutes)

**Agent Assignment**: Backend Agent + Security Review

#### Implementation Overview
The Backend Agent will autonomously implement a complete JWT-based authentication system following modern security practices.

**Expected Implementation**:
```python
# Database Models (Generated by Backend Agent)
class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    articles = relationship("Article", back_populates="author")
    comments = relationship("Comment", back_populates="author")

# Authentication Service (Generated by Backend Agent)
class AuthService:
    async def create_user(self, user_data: UserCreate) -> User:
        """Create new user with hashed password."""
        
    async def authenticate_user(self, email: str, password: str) -> Optional[User]:
        """Authenticate user credentials."""
        
    async def create_access_token(self, user_id: int) -> str:
        """Generate JWT access token."""
        
    async def verify_token(self, token: str) -> Optional[User]:
        """Verify and decode JWT token."""
```

**Frontend Components (Generated by Frontend Agent)**:
```typescript
// Authentication Components
@customElement('auth-form')
export class AuthForm extends LitElement {
  static styles = css`
    /* Responsive authentication form styles */
  `;

  @property({ type: String }) mode: 'login' | 'register' = 'login';
  @state() private isLoading = false;
  @state() private errors: string[] = [];

  private async handleSubmit(event: Event) {
    // AI-generated form handling with validation
  }

  private async authenticateUser(credentials: AuthCredentials) {
    // AI-generated API integration
  }

  render() {
    return html`
      <form @submit=${this.handleSubmit}>
        <!-- AI-generated accessible form -->
      </form>
    `;
  }
}
```

#### Autonomous Development Workflow

**Step 1: Agent Planning Phase**
```bash
# The orchestrator will automatically:
1. Analyze authentication requirements
2. Assign tasks to specialized agents
3. Create implementation plan
4. Establish success criteria

# You'll see output like:
ğŸ¤– Orchestrator: Planning authentication system implementation
ğŸ“‹ Backend Agent: Assigned database models and API endpoints
ğŸ¨ Frontend Agent: Assigned UI components and state management
ğŸ§ª QA Agent: Assigned test coverage and security validation
```

**Step 2: Parallel Development**
```bash
# Agents work simultaneously:
Backend Agent:
  âœ… Creating User model with SQLAlchemy
  âœ… Implementing password hashing with bcrypt
  âœ… Designing JWT token management
  âœ… Writing authentication endpoints

Frontend Agent:
  âœ… Creating authentication form component
  âœ… Implementing form validation
  âœ… Adding loading states and error handling
  âœ… Integrating with API service

QA Agent:
  âœ… Writing unit tests for authentication
  âœ… Creating integration tests
  âœ… Implementing security validation
  âœ… Performance testing API endpoints
```

**Step 3: Integration and Validation**
```bash
# Automatic integration and testing:
ğŸ”„ Orchestrator: Coordinating component integration
ğŸ§ª QA Agent: Running comprehensive test suite
âœ… All authentication tests passed (25/25)
ğŸ”’ Security validation completed
âš¡ Performance tests passed (<200ms response time)
```

### 3.2 Article Management System (60 minutes)

**Agent Assignment**: Backend Agent + Frontend Agent + QA Agent (Full Coordination)

#### Comprehensive Article Features

**Backend Implementation (Autonomous)**:
```python
# Article Models (AI-Generated)
class Article(Base):
    __tablename__ = "articles"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False, index=True)
    slug = Column(String, unique=True, index=True, nullable=False)
    description = Column(String, nullable=False)
    body = Column(Text, nullable=False)
    author_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Advanced features
    view_count = Column(Integer, default=0)
    like_count = Column(Integer, default=0)
    is_published = Column(Boolean, default=False)
    tags = Column(JSON, default=list)
    
    # Relationships
    author = relationship("User", back_populates="articles")
    comments = relationship("Comment", back_populates="article")
    favorites = relationship("ArticleFavorite", back_populates="article")

# Article Service (AI-Generated)
class ArticleService:
    async def create_article(self, article_data: ArticleCreate, author_id: int) -> Article:
        """Create new article with auto-generated slug."""
        
    async def get_articles(self, skip: int = 0, limit: int = 20, author_id: Optional[int] = None) -> List[Article]:
        """Get articles with pagination and filtering."""
        
    async def search_articles(self, query: str) -> List[Article]:
        """Full-text search in articles."""
        
    async def update_article(self, article_id: int, article_data: ArticleUpdate, user_id: int) -> Article:
        """Update article with ownership validation."""
```

**Frontend Components (AI-Generated)**:
```typescript
// Article Editor Component
@customElement('article-editor')
export class ArticleEditor extends LitElement {
  static styles = css`
    /* Rich text editor styling */
    .editor {
      min-height: 300px;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 1rem;
    }
    
    .toolbar {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      padding: 0.5rem;
      background: #f5f5f5;
      border-radius: 4px;
    }
  `;

  @property({ type: Object }) article?: Article;
  @state() private isEditing = false;
  @state() private isSaving = false;

  private async saveArticle() {
    // AI-generated save logic with validation
  }

  private async handleImageUpload(event: Event) {
    // AI-generated image handling
  }

  render() {
    return html`
      <div class="article-editor">
        <div class="toolbar">
          <!-- AI-generated rich text toolbar -->
        </div>
        <div class="editor" contenteditable="true">
          <!-- AI-generated content editable area -->
        </div>
      </div>
    `;
  }
}

// Article List Component
@customElement('article-list')
export class ArticleList extends LitElement {
  @state() private articles: Article[] = [];
  @state() private isLoading = false;
  @state() private hasMore = true;

  async connectedCallback() {
    super.connectedCallback();
    await this.loadArticles();
  }

  private async loadArticles() {
    // AI-generated infinite scroll implementation
  }

  render() {
    return html`
      <div class="article-list">
        ${this.articles.map(article => html`
          <article-card .article=${article}></article-card>
        `)}
        ${this.isLoading ? html`<loading-spinner></loading-spinner>` : ''}
      </div>
    `;
  }
}
```

#### Advanced AI Development Features

**Real-time Development Monitoring**:
```bash
# Watch agents work in real-time:
ğŸ¤– Backend Agent: Implementing article CRUD operations...
  ğŸ“ Creating Article model with relationships
  ğŸ” Adding full-text search capabilities
  ğŸ·ï¸ Implementing tag system
  âš¡ Optimizing database queries

ğŸ¨ Frontend Agent: Building article components...
  ğŸ“„ Creating rich text editor component
  ğŸ“‹ Implementing article list with infinite scroll
  ğŸ¯ Adding responsive design patterns
  ğŸ”„ Setting up state management

ğŸ§ª QA Agent: Ensuring quality...
  âœ… Writing comprehensive test coverage
  ğŸ”’ Validating security measures
  âš¡ Performance testing with large datasets
  â™¿ Accessibility compliance checking
```

### 3.3 Social Features & Comments (45 minutes)

**Agent Assignment**: Multi-Agent Coordination (All Agents)

#### Advanced Social Platform Features

**Comment System (AI-Generated)**:
```python
# Threaded Comments Model
class Comment(Base):
    __tablename__ = "comments"
    
    id = Column(Integer, primary_key=True, index=True)
    body = Column(Text, nullable=False)
    author_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    article_id = Column(Integer, ForeignKey("articles.id"), nullable=False)
    parent_id = Column(Integer, ForeignKey("comments.id"), nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Threading support
    level = Column(Integer, default=0)
    path = Column(String, index=True)  # Materialized path for threading
    
    # Relationships
    author = relationship("User", back_populates="comments")
    article = relationship("Article", back_populates="comments")
    replies = relationship("Comment", backref=backref("parent", remote_side=[id]))

# User Following System
class UserFollow(Base):
    __tablename__ = "user_follows"
    
    follower_id = Column(Integer, ForeignKey("users.id"), primary_key=True)
    followed_id = Column(Integer, ForeignKey("users.id"), primary_key=True)
    created_at = Column(DateTime, default=datetime.utcnow)
```

**Interactive Frontend Components (AI-Generated)**:
```typescript
// Comment Thread Component
@customElement('comment-thread')
export class CommentThread extends LitElement {
  static styles = css`
    .comment {
      margin-left: calc(var(--level, 0) * 2rem);
      border-left: 2px solid #eee;
      padding-left: 1rem;
      margin-bottom: 1rem;
    }
    
    .comment-replies {
      margin-top: 1rem;
    }
  `;

  @property({ type: Array }) comments: Comment[] = [];
  @property({ type: Number }) maxDepth = 5;

  private renderComment(comment: Comment, level: number = 0) {
    return html`
      <div class="comment" style="--level: ${level}">
        <comment-item .comment=${comment}></comment-item>
        ${comment.replies?.length > 0 && level < this.maxDepth ? html`
          <div class="comment-replies">
            ${comment.replies.map(reply => 
              this.renderComment(reply, level + 1)
            )}
          </div>
        ` : ''}
      </div>
    `;
  }

  render() {
    return html`
      <div class="comment-thread">
        ${this.comments.map(comment => this.renderComment(comment))}
      </div>
    `;
  }
}

// User Profile & Following
@customElement('user-profile')
export class UserProfile extends LitElement {
  @property({ type: Object }) user!: User;
  @state() private isFollowing = false;
  @state() private followerCount = 0;

  private async toggleFollow() {
    // AI-generated follow/unfollow logic
  }

  render() {
    return html`
      <div class="user-profile">
        <div class="profile-header">
          <img src="${this.user.avatar}" alt="${this.user.username}" />
          <h1>${this.user.username}</h1>
          <p>${this.user.bio}</p>
          <button @click=${this.toggleFollow}>
            ${this.isFollowing ? 'Unfollow' : 'Follow'}
          </button>
        </div>
        <div class="profile-stats">
          <span>${this.followerCount} followers</span>
          <span>${this.user.following_count} following</span>
        </div>
      </div>
    `;
  }
}
```

## ğŸ¯ Agent Coordination in Action

### Real-time Development Session

**Example 4-Hour Autonomous Session**:

```bash
ğŸš€ LeanVibe Agent Hive Session Started
ğŸ“Š Target: Complete Medium clone core features
ğŸ‘¥ Agents: Backend, Frontend, QA, Orchestrator

Hour 1: Authentication System
ğŸ¤– Orchestrator: Coordinating authentication implementation
ğŸ“Š Backend Agent: 
  âœ… User model created (2 min)
  âœ… Password hashing implemented (5 min)
  âœ… JWT service created (8 min)
  âœ… Auth endpoints implemented (15 min)
ğŸ¨ Frontend Agent:
  âœ… Auth form component created (10 min)
  âœ… Login/register flow implemented (20 min)
  âœ… Token management added (5 min)
ğŸ§ª QA Agent:
  âœ… Auth tests written (25 tests) (15 min)
  âœ… Security validation completed (10 min)

Hour 2: Article Management
ğŸ¤– Orchestrator: Scaling to article system
ğŸ“Š Backend Agent:
  âœ… Article model with relationships (10 min)
  âœ… CRUD operations implemented (20 min)
  âœ… Search functionality added (15 min)
  âœ… Tag system implemented (15 min)
ğŸ¨ Frontend Agent:
  âœ… Article editor component (25 min)
  âœ… Article list with pagination (20 min)
  âœ… Rich text editing (15 min)
ğŸ§ª QA Agent:
  âœ… Article tests (35 tests) (20 min)
  âœ… Performance testing (15 min)

Hour 3: Social Features
ğŸ¤– Orchestrator: Implementing social interactions
ğŸ“Š Backend Agent:
  âœ… Comment threading system (25 min)
  âœ… User following relationships (15 min)
  âœ… Feed generation algorithm (20 min)
ğŸ¨ Frontend Agent:
  âœ… Comment components (20 min)
  âœ… User profile pages (25 min)
  âœ… Social interaction UI (15 min)
ğŸ§ª QA Agent:
  âœ… Social feature tests (30 tests) (25 min)
  âœ… Integration testing (20 min)

Hour 4: Integration & Polish
ğŸ¤– Orchestrator: Final integration and optimization
ğŸ“Š All Agents: 
  âœ… Cross-feature integration
  âœ… Performance optimization
  âœ… Security hardening
  âœ… Final testing and validation

ğŸ‰ Session Complete: Full Medium clone with 90+ tests, 95%+ coverage
```

## ğŸ”„ Human-AI Collaboration Points

### When Human Input is Required

**Architecture Decisions (Confidence < 80%)**:
- Database schema modifications affecting existing data
- Authentication strategy changes
- Third-party service integrations

**Creative Decisions**:
- UI/UX design preferences
- Branding and styling choices
- Content organization patterns

**Business Logic Clarification**:
- Complex business rules
- Workflow specifications
- User experience flows

### Collaborative Development Workflow

```bash
# Agent requests guidance
ğŸ¤– Backend Agent: "User relationship model design - should users follow other users or articles?"

# Human provides direction
ğŸ‘¤ Human: "Users should be able to follow both other users and articles. Implement both relationships."

# Agent continues autonomously
ğŸ¤– Backend Agent: "Understood. Implementing dual follow system with user_follows and article_follows tables."

# Quality validation
ğŸ§ª QA Agent: "Validating dual follow system implementation..."
âœ… All tests pass (12/12)
âœ… Performance within targets
âœ… Database constraints validated
```

## ğŸ Phase 3 Completion

**Expected Outcomes**:
- âœ… Complete user authentication system with JWT tokens
- âœ… Full article management with rich text editing
- âœ… Threaded comment system
- âœ… User following and social features
- âœ… Comprehensive test coverage (90+ tests)
- âœ… Production-ready code quality

**What You've Experienced**:
- **AI-First Development**: Watched agents autonomously implement complex features
- **Multi-Agent Coordination**: Seen specialized agents work together effectively
- **Quality Automation**: Experienced comprehensive automated testing and validation
- **Human-AI Collaboration**: Participated in guided autonomous development

### Time Checkpoint

**Target**: 2-3 hours  
**Typical Range**: 2-4 hours (depending on agent performance and complexity)

The actual development time may vary based on:
- Agent coordination efficiency
- Code complexity requirements
- Test coverage thoroughness
- Integration challenges

## ğŸ¯ Next Phase

**Ready for Phase 4?** â†’ [Testing & Deployment](./phase4-testing-deployment.md)

In Phase 4, you'll:
- Run comprehensive testing suites across all components
- Experience automated quality validation
- Deploy the application to production
- Set up monitoring and observability
- Validate the complete Medium clone functionality

---

**Having Issues?** If any agent encounters problems or requires guidance, check the [Troubleshooting Guide](./troubleshooting.md) or provide specific direction to continue development.